\documentclass{article}
\setlength{\oddsidemargin}{0in}
\setlength{\textwidth}{6.5in}
\setlength{\topmargin}{-.5in}
\setlength{\textheight}{9in}
\title{Carmen Messages}
\author{Nicholas Roy and Michael Montemerlo and Sebastian Thrun}

\begin{document}

\maketitle

\section{Introduction}

In all messages, the distance units are in metres. Angle measurements in
radians, in the range $-\pi$ to $\pi$. Velocity units are m/sec. The timestamp
is given as the number of seconds since the unix epoch, and is a double, where
the fractional part is computed from the \verb!tv_usec! field of the
\verb!timeval! struct returned by \verb!gettimeofday!. More information on
units and co-ordinate frames can be found in the Carmen Programming Style
Guide. 

\section{Getting Data from Carmen}

Sensor data currently comes from one of two sources: the base module (such as
scout, pioneer, etc.) provides raw odometry data and may provide sonar data,
bumper data and infra-red (IR) data. The laser module may provide laser data.

\subsubsection{Subscribing}

All of the following messages can be subscribed to by using helper functions
in the appropriate \verb!xxx_interface! library, e.g., \verb!base_interface!.
The helper functions are all of the form:

\begin{verbatim}
void carmen_robot_subscribe_xxxx_message(carmen_robot_xxx_message *msg,
                                         carmen_handler_t handler, 
                                         carmen_subscribe_t subscribe_how);
\end{verbatim}

where \verb!carmen_handler_t! and \verb!carmen_subscribe_t! are defined as

\begin{verbatim}
typedef enum {CARMEN_UNSUBSCRIBE, CARMEN_SUBSCRIBE_LATEST, 
              CARMEN_SUBSCRIBE_ALL} carmen_subscribe_t;
typedef void (*carmen_handler_t)(void *);
\end{verbatim}

If the \verb!msg! field of the subscribe function is \verb!NULL!, then a
static message is automatically allocated and returned as the argument to
\verb!handler!, otherwise the message pointer passed to the subscribe function
is always used. In all cases, the same memory is re-used for all handled
messages of the same message name, and passed as an argument to the handler
function. 

If the \verb!handler! field of the subscribe function is \verb!NULL!, no
handler is called, but the memory pointed to by \verb!msg! is updated
regularly. If both \verb!handler! and \verb!msg! are both \verb!NULL!, your
program will spend a fair chunk of time doing nothing useful for you. 

The \verb!subscribe_how! field allows the user to either unsubscribe, or to
start a new subscription. Subscribing only to the latest message allows the
module to fall behind in processing messages without serious consequences. It
should be pointed out that subscribing to all messages
(\verb!CARMEN_SUBSCRIBE_ALL!) does not guarantee all messages. Currently, the
upper limit for the queue size is 1000 messages. If an IPC process actually
subscribes to \emph{all} messages and falls seriously behind (or wedges),
central can run out of memory, or even worse, the TCP stack can
overflow. Consequently, the Carmen subscription functions limit the maximum
message queue size to 1000. A resourceful programmer can increase this queue
(or even remove the queue size), but it is not clear this would ever be
necessary. 

\subsubsection{Requesting Data Explicitly}

Some of these messages can also be obtained using explicit queries. To date,
the only robot data that can be obtained using queries are from localize and
navigator. Specifically, \verb!carmen_localize_globalpos_message!,
\verb!carmen_localize_particle_message!,
\verb!carmen_navigator_status_message! and
\verb!carmen_navigator_plan_message! can all be obtained using specific query
interface functions, which return the appropriate messages directly.

These functions create new memory every time they return successfully;
consequently, they should be used with care.

\subsection{Sensor Data from the Base}

The \verb!timestamp! field in all messages is defined to be the time when the
data was first created or acquired (e.g, by \verb!scout! or \verb!simulator!).

\subsubsection{Odometry}

\begin{verbatim}
typedef struct {
  double x, y, theta;
  double tv, rv;
  double acceleration;
  double timestamp;
  char host[10];
} carmen_base_odometry_message

void carmen_base_subscribe_odometry_message(carmen_base_odometry_message *odometry,
                                            carmen_handler_t handler,
                                            carmen_subscribe_t subscribe_how);
\end{verbatim}

The \verb!x, y, theta! fields are the raw odometry, from the time the robot
was turned on. The tv and rv fields are the translational and rotational
velocities of the robot. For robots that have differential drive (as opposed
to synchrodrive), these velocities are computed from the left and right wheel
velocities that base actual uses. 

\subsubsection{Sonar}

Sonar sensing is not properly supported by Carmen right now, and so
subscribing to \verb!carmen_base_sonar_message! messages may sometimes not
work properly. But, if you care, it looks like:

\begin{verbatim}
typedef struct {
  int num_sonars;
  double *range;
  carmen_point_p sonar_offsets;
  double timestamp;
  char host[10];
} carmen_base_sonar_message

typedef struct {
  int rate;
  int num_sonars;
  int *order;
  carmen_point_t *sonar_offsets;
  double timestamp;
  char host[10];
} carmen_base_sonar_conf_message

void carmen_base_subscribe_sonar_message(carmen_base_sonar_message *sonar,
                                         carmen_handler_t handler,
                                         carmen_subscribe_t subscribe_how);
\end{verbatim}

The sonar message reports a recent set of sonar range data from the
base. There should be as many range points and offset points as described by
\verb!num_sonars!. The \verb!sonar_offsets! describes the physical location
and orientation of each transducer from the centre of the robot. 

There is currently no way to query the firing rate or order of the sonar
transducers, and the sonar\_conf message is not yet supported. (Or even defined
by any module.)

\subsubsection{Bumper and IR sensors}

\begin{verbatim}
typedef struct {
  int num_bumpers;
  char *states;
  double timestamp;
  char host[10];
} carmen_base_bumper_message;

typedef struct {
  int num_irs;
  double *range;
  double timestamp;
  char host[10];
} carmen_base_ir_message;
\end{verbatim}

These messages will probably change, and are not yet supported.

\subsubsection{Laser data}

Laser data is defined as a set of ranges, of number given by the
\verb!num_readings! field, contained in \verb!range!. The number of ranges is
almost always 180, since we only support SICK lasers in $1^\circ$ increments
at the moment. Each range measurement is the distance to the nearest obstacle
along some heading. The first range is along the $-\pi/2$ direction (of
course, in the robot's local frame of reference, where $0^\circ$ is directly
ahead) and the last range is along the $+\pi/2-\frac{1}{180}$ heading. In
degrees, that is from $-90^\circ$ to $+89^\circ$. The increment is currently
$1^\circ$. The order is right-handed (counter-clockwise). Remember that this
is all with reference to a laser that is mounted facing the front of the
robot, with the laser right way up (the serial and power connectors are on
top). For rear laser messages, the measurements go from $+\pi/2$ through $\pi$
to $-\pi/2-\frac{1}{180}$. If you mount the laser upside down, the
measurements go from $+\pi/2$ through $0$ to $-\pi/2-\frac{1}{180}$. For
forward pointing lasers, you can pretty much assume the laser is mounted the
right way up.

The \verb!timestamp! field in all messages is defined to be the time when the
data was first created or acquired (e.g, by \verb!laser! or \verb!simulator!),
not the timestamp of some intermediate process (such as the correction applied
by \verb!robot! when applying odometry interpolation and correction).
Similarly, the \verb!host!field is defined to be the hostname associated with
the origin of the data, not the hostname of some intermediary converting the
data from raw form to interpolated form. 

\begin{verbatim}
typedef struct {
  int num_readings;
  double *range;
  double timestamp;
  char host[10];
} carmen_laser_laser_message;

void carmen_laser_subscribe_frontlaser_message(carmen_laser_laser_message *laser,
                                               carmen_handler_t handler,
                                               carmen_subscribe_t subscribe_how);
void carmen_laser_subscribe_rearlaser_message(carmen_laser_laser_message *laser,
                                              carmen_handler_t handler,
                                              carmen_subscribe_t subscribe_how);
\end{verbatim}

This message is defined by \verb!laser! and by \verb!simulator!, and the same
message struct is used by both \verb!carmen_laser_frontlaser! and
\verb!carmen_laser_rearlaser! messages. As a consequence, there is no way to
tell from a message itself whether or not the message is a front laser message
or a rear laser message. This hopefully will be fixed in a future release.

\subsubsection{Robot messages}

These messages are defined and emitted by \verb!robot!.

\begin{itemize}

\item \verb!carmen_robot_laser_message!

\begin{verbatim}
typedef struct {
  int num_readings;
  double *range;
  char *tooclose;
  double x, y, theta;
  double odom_x, odom_y, odom_theta;
  double forward_safety_dist, side_safety_dist;
  double turn_axis;
  double timestamp;
  char host[10];
} carmen_robot_laser_message;

void carmen_robot_subscribe_frontlaser_message(carmen_robot_laser_message *laser,
                                               carmen_handler_t handler,
                                               carmen_subscribe_t subscribe_how);

void carmen_robot_subscribe_rearlaser_message(carmen_robot_laser_message *laser,               
                                              carmen_handler_t handler,
                                              carmen_subscribe_t subscribe_how);

\end{verbatim}

The \verb!carmen_robot_laser_message! has raw odometry attached to it. The
\verb!robot! module attempts to adjust for clock skews and interpolate the
true robot position of the data correctly based on time stamps. Consequently,
after a \verb!carmen_laser_laser_message! is received, the corresponding
\verb!carmen_robot_laser_message! will not be emitted until a
\verb!carmen_base_odometry_message! with a later timestamp is received. The
odometry fields are \verb!x!, \verb!y! and \verb!theta!. These fields are in
fact the interpolated position of \emph{this laser}, based on the laser offset
parameters for this laser. The interpolated odometry for the robot itself are
the \verb!odom_x!, \verb!odom_y! and \verb!odom_theta!  fields. Consequently,
front and rear laser messages with the same timestamps should have different
values for their \verb!x!, \verb!y! and \verb!theta!  fields, but identical
values for their \verb!odom_x!, \verb!odom_y! and \verb!odom_theta! fields.

The \verb!robot! module is also used to perform collision avoidance, stopping
the robot if the laser measurements indicate an obstacle inside safety
margins. The \verb!tooclose! array labels each range measurement as to whether
or not it lies inside the robot safety margins. There are as many
\verb!tooclose! elements as there are \verb!range! elements (as given by the
\verb!num_readings! field). If \verb!msg.tooclose[i]! is 1, then the range
\verb!msg.range[i]! is inside the safety margin. 

The same message struct is used by both the \verb!carmen_robot_frontlaser!
and \verb!carmen_robot_rearlaser!  messages. Again, there is no way to tell
from a message itself whether or not the message is a front laser message or a
rear laser message. This hopefully will be fixed in a future release.

\item \verb!carmen_robot_sonar_message!

\begin{verbatim}
typedef struct {
  int num_sonars;
  double sensor_angle;          //width of sonar cone
  double *range;
  char *tooclose;
  carmen_point_t robot_location;
  carmen_point_p sonar_locations;
  carmen_point_p sonar_offsets;
  double forward_safety_dist, side_safety_dist;
  double turn_axis;
  double timestamp;
  char host[10];
} carmen_robot_sonar_message;
\end{verbatim}

The exact meaning of some these fields is a little bit of a mystery. This
message is still in the experimental stage.

\end{itemize}

\subsection{Map-based Navigation Messages}

\subsubsection{Localize Messages}

\begin{itemize}

\item \verb!carmen_localize_globalpos_message!

\begin{verbatim}
typedef struct {
  carmen_point_t globalpos, globalpos_std;
  carmen_point_t odometrypos;
  double globalpos_xy_cov;
  int converged;
  double timestamp;
  char host[10];
} carmen_localize_globalpos_message

void carmen_localize_subscribe_globalpos_message(carmen_localize_globalpos_message *globalpos,
                                                 carmen_handler_t handler,
                                                 carmen_subscribe_t subscribe_how);
\end{verbatim}

This message reports on the current robot pose estimate, given by localize.

The \verb!globalpos! field is mean robot position (computed from the particle
filter), and is given in the global frame of reference. (See the Carmen Style
Guide.) The \verb!odometrypos! is the odometry of the robot at the time the
current estimate was computed. It is therefore possible to estimate the true
position of the robot for a short duration after the last
\verb!carmen_localize_globalpos_message! by finding the relative displacement
(translational and rotational) of the robot between the current odometry, and
the odometry of the last \verb!carmen_localize_globalpos_message!, and then
adding this displacement to the \verb!globalpos! field. There is a helper
function in \verb!liblocalize_interface! called
\verb!carmen_localize_correct_odometry! that does exactly this. 

Notice that Carmen localize no longer explicitly provides correction
parameters, but instead provides a functional way to correct odometry. 

The \verb!globalpos_std! gives the variances of the position estimates,
$\sigma_x^2, \sigma_y^2, \sigma_\theta^2$. The \verb!globalpos_xy_cov! field
gives the covariance $\sigma_{xy}$. 

The \verb!converged! field indicates whether localize is currently in global
or tracking mode. If localize has converged (is in tracking mode) then the
position estimate has high confidence. When localize believes it is lost, it
switches back to global localization mode and the \verb!converged! field
switches to 1. 

Additional messages about the state of localize are:

\item \verb!carmen_localize_particle_message! -- This message gives the full
state of the pose particle filter (and people particle filters, if people
tracking is running.)

\item \verb!carmen_localize_sensor_message! -- This message contains
information about how localize has used each laser reading, such as whether a
laser readings was integrated (or not), and which person filter the reading
was assigned (if any).

\item \verb!carmen_localize_people_message! -- This message contains the
current state of the person tracker, if it is running. 
\end{itemize}

\subsubsection{Autonomous Navigation}

\begin{itemize}

\item \verb!carmen_navigator_plan_message!

\begin{verbatim}
typedef struct {
  int autonomous;
  int goal_set;
  carmen_point_t goal;
  carmen_traj_point_t robot;
  double timestamp;
  char host[10];
} carmen_navigator_status_message;

void carmen_navigator_subscribe_status_message(carmen_navigator_status_message *status,
                                               carmen_handler_t handler,
                                               carmen_subscribe_t subscribe_how);

int carmen_navigator_query_status(carmen_navigator_status_message **status);

\end{verbatim}

The \verb!autonomous! field is 1 if the robot is currently trying to
autonomously navigate to the goal, perhaps because a user clicked the
\verb!Autonomous! button in the navigator\_panel display. When the robot
changes to non-autonomous mode, a
\verb!carmen_navigator_autonomous_stopped_message! is emitted (see below), and
contains the reason for changing to non-autonomous mode.

The \verb!goal_set! field is 1 if the navigator has received any goal at
all. If no goal has been set, then it is not possible for the navigator go
into autonomous mode. 

The \verb!goal! field reports on what the navigator's current goal. The
navigator does not (and should not ever) support multiple goal destinations. 

The \verb!robot! field is the navigator's estimate of the current robot
position in the global reference frame (see the Carmen Style Guide). This is
based on the latest estimate from localize, combined with any subsequent
odometric updates the navigator has received. The \verb!robot! position field
reported by the navigator should never lag behind (in time) localize's
estimate. 

\item \verb!carmen_navigator_plan_message!

\begin{verbatim}
typedef struct {
  carmen_traj_point_t *path;
  int path_length;
  double timestamp;
  char host[10];
} carmen_navigator_plan_message;

void carmen_navigator_subscribe_plan_message(carmen_navigator_plan_message *plan,
                                           carmen_handler_t handler,
                                           carmen_subscribe_t subscribe_how);

int carmen_navigator_query_plan(carmen_navigator_plan_message **plan);

\end{verbatim}

If the path length is 0, then there is no path from the current robot location
to the goal. The first point in the path should always be the robot's current
position as reported by the \verb!carmen_navigator_status_message!, and the
last point in the path should always be the goal as reported by
\verb!carmen_navigator_status_message!. 

\item \verb!carmen_navigator_autonomous_stopped_message!

\begin{verbatim}
typedef struct {
  double timestamp;
  char host[10];
  carmen_navigator_reason_t reason;
} carmen_navigator_autonomous_stopped_message;

void carmen_navigator_subscribe_autonomous_stopped_message
                    (carmen_navigator_autonomous_stopped_message *autonomous_stopped,
                     carmen_handler_t handler,
                     carmen_subscribe_t subscribe_how);
\end{verbatim}

The \verb!reason! field can take one of three values:
\begin{itemize}
\item \verb!CARMEN_NAVIGATOR_GOAL_REACHED_v! -- This means that the robot has
reached the goal destination (that is, is within the
\verb!robot_approach_dist! of the goal).
\item \verb!CARMEN_NAVIGATOR_USER_STOPPED_v! -- This means that some other
process (such as the navigator\_panel) published a
\verb!carmen_navigator_stop_message!. 
\item \verb!CARMEN_NAVIGATOR_UNKNOWN_v! -- This means some (unknown) reason
caused autonomous navigation to stop. The navigator does not currently ever
emit this reason.
\end{itemize}

\end{itemize}

\section{Commanding the robot}

While it is (obviously) possible to send messages directly to the base module,
this is not an exposed interface. Sending velocities directly to the base
side-steps the last-mile collision avoidance module, and can also result in
all kinds of pathologies as modules fight for control of the robot.

\subsection{Moving the Robot}

\begin{itemize}

\item \verb!carmen_robot_velocity_message!

\begin{verbatim}
typedef struct {
  double tv, rv;
  double timestamp;
  char host[10];
} carmen_robot_velocity_message;

void carmen_robot_velocity_command(double tv, double rv);
\end{verbatim}

Publishing this message will tell the \verb!robot! module to make the robot go
at the specified translation velocity \verb!tv! specified rotational velocity
\verb!rv!.

The robot may not be able to go at these speeds, because either they exceed
the maximum velocity, or because an obstacle is too close. There is no
diagnostic for the first condition yet. The second condition can be detected
by examining the \verb!tooclose! field of the
\verb!carmen_robot_laser_message!.

\item \verb!carmen_robot_vector_move_message!

\begin{verbatim}
typedef struct {
  double distance, theta;
  double timestamp;
  char host[10];
} carmen_robot_vector_move_message;

void carmen_robot_velocity_command(double distance, double theta);
\end{verbatim}

Publishing this message will take advantage of a PD loop in the robot module
to make the robot go to specific target point. This control loop contains no
planning, so if an obstacle intervenes between the robot and the target, the
robot will stop. 

The target point set by this message is given by the \verb!distance! and
\verb!theta! fields, which are in metres and radians respectively, and are
\emph{relative} to the robot's current pose. Consequently, a positive
\verb!distance! with a \verb!theta! of 0 would drive the robot forward
\verb!distance! metres. Similarly, a \verb!distance! of 0 and a \verb!theta! 
of $\pi$ would cause the robot to rotate $180^\circ$, regardless of current
orientation. 

\end{itemize}

\subsection{Initializing Localize}

\subsubsection*{carmen\_localize\_initialize\_message}

This message provides a way to initialize localization.

\begin{verbatim}
typedef struct {
  int distribution;
  carmen_point_t mean, std;
  double timestamp;
  char host[10];
} carmen_localize_initialize_message;
\end{verbatim}

The \verb!distribution! specifies the kind of distribution to use for
initialization. At the moment only one type of distribution is supported:
\verb!CARMEN_INITIALIZE_GAUSSIAN!. (The \verb!localize_messages.h! file also
lists a \verb!CARMEN_INITIALIZE_UNIFORM! distribution type, but this is not
currently supported by localize itself.) 

The 3-dimensional point \verb!mean! specifies the $x, y, \theta$ mean of the
gaussian, and \verb!std! specified the $\sigma_x, \sigma_y, \sigma_\theta$
standard deviations of the gaussian. Reasonable values for the standard
deviations are $(0.2m, 0.2m, 4.0^\circ)$. 

It is also possible to initialize localize through the navigator by using the
\verb!carmen_navigator_set_robot! or \verb!carmen_navigator_set_robot_map! 
messages, but these messages are deprecated.

\subsubsection{Setting A Goal}

This message provides a way to set the goal or destination for navigation. It
is not possible (nor should it ever be possible) to set multiple goals inside
the navigator.

\begin{verbatim}
typedef struct {
  double x, y;
  double timestamp;
  char host[10];
} carmen_navigator_set_goal_message;

int carmen_navigator_set_goal(double x, double y);

typedef struct {
  char *placename;
  double timestamp;
  char host[10];
} carmen_navigator_placename_message;

int carmen_navigator_set_goal_place(char *name);

\end{verbatim}

The $(x, y)$ fields should be self-explanatory as the goal position, in the
global reference frame (see the Carmen Style Guide), as always in metres.

If the map contains place names, then it is also possible to set the goal
position using a \verb!carmen_navigator_placename_message!, and the
\verb!carmen_navigator_set_goal_place! helper function. This has no effect if
the map does not contain a place name that matches. 

\subsection{Autonomous Motion}

These messages toggle the navigator in and out of autonomous motion. 

\begin{verbatim}
typedef struct {
  double timestamp;
  char host[10];
} carmen_navigator_go_message;

typedef struct {
  double timestamp;
  char host[10];
} carmen_navigator_stop_message;

int carmen_navigator_stop(void);

int carmen_navigator_go(void);

\end{verbatim}

If the robot is already at the current goal position, then the
\verb!carmen_navigator_go_command! will cause the navigator to change
momentarily into autonomous mode, and then switch back again, emitting a
\verb!carmen_navigator_autonomous_stopped_message! with
\verb!CARMEN_NAVIGATOR_GOAL_REACHED_v! as the reason.

When the navigator receives a \verb!carmen_navigator_stop_message!, then a
\verb!carmen_navigator_autonomous_stopped_message! is emitted with
\verb!CARMEN_NAVIGATOR_USER_STOPPED_v! as the reason.

\section{Getting Maps}

\subsubsection{Grid Maps}

\begin{verbatim}
typedef struct {
  double timestamp;
  char host[10];
} carmen_gridmap_request;

int carmen_map_get_gridmap(carmen_map_p map);
\end{verbatim}

\subsubsection{Map Placelists}

\begin{verbatim}
typedef struct {  
  carmen_place_p places;
  int num_places;
  double timestamp;
  char host[10];
} carmen_map_placelist_message;

int carmen_map_get_placelist(carmen_map_placelist_p placelist);
\end{verbatim}

\subsubsection{Map Placelists}

\begin{verbatim}
typedef struct {  
  carmen_offlimits_p offlimits_list;
  int list_length;
  double timestamp;
  char host[10];
} carmen_map_offlimits_message;

int carmen_map_get_offlimits(carmen_offlimits_p *offlimits, int *list_length);
\end{verbatim}

\subsubsection{Navigator Maps}

\begin{verbatim}
typedef struct {
  float *data;    
  int size;
  carmen_map_config_t config;
  carmen_navigator_map_t map_type;
  double timestamp;
  char host[10];
} carmen_navigator_map_message;  

int carmen_navigator_get_map(carmen_navigator_map_t map_type, 
                           carmen_navigator_map_message **map_pointer);
\end{verbatim}

\section{Getting Parameters}

Parameters can be acquired from the parameter server using functions in
\verb!libparam_interface!, eg: 

\begin{verbatim}
int carmen_param_get_int(char *variable, int *return_value);
int carmen_param_get_double(char *variable, double *return_value);
int carmen_param_get_onoff(char *variable, int *return_value);
int carmen_param_get_string(char *variable, char **return_value);
\end{verbatim}

The conversion of parameters to ints, doubles, etc. is done on demanded by the
interface library. If you do not wish the library to convert the parameter to
the appropriate type, simply request the parameter as a string.

If there is no definition for the parameter requested, then the library will
output a warning to the terminal, unless this warning has been turned off
using \verb!carmen_param_allow_unfound_variables(1);!. 

Also, as a convience, variables can be requested either by specifying the
fully qualified \verb!module_param-name! name, or by first specifying a module
using \verb!carmen_param_set_module(char *)!, and the specifying just the
\verb!param-name! form. 

\subsection{Subscribing to Changes}

Some processes may wish to subscribe to changes to parameters during their
execution, for example changing the robot speed or acceleration profile, or
changing the \verb!robotgraph! display parameters. Of course, some processes
should not suscribe to some parameter changes: changing the number of
particles localize uses during execution would result in disaster.

Parameter changes can be subscribed using the functions below:
\begin{verbatim}
void carmen_param_subscribe_int(char *module, char *variable, int *variable_address, 
                                carmen_param_change_handler_t handler);
void carmen_param_subscribe_double(char *module, char *variable, double *variable_address, 
                                   carmen_param_change_handler_t handler);
void carmen_param_subscribe_onoff(char *module, char *variable, int *variable_address, 
                                  carmen_param_change_handler_t handler);
void carmen_param_subscribe_string(char *module, char *variable, char **variable_address, 
                                   carmen_param_change_handler_t handler);
\end{verbatim}

These functions take a module and variable name as parameters. The
subscription mechanism can either silently change variable values as
parameters change, or can invoke a callback when a parameter is changed. If
the \verb!variable_address! parameter is non-NULL, then the new parameter
value is stored at this address (in the case of strings, this is a pointer to
some newly-malloc'd memory containing the new string definition. If the
variable address is non-NULL when the parameter changes, the old memory is
freed.) If the \verb!handler! parameter is non-NULL, then function pointed to
by \verb!handler! is invoked whenever the parameter changes. If both are
non-NULL, then the variable changes and then the callback invoked. If both are
NULL, then the subscription mechanism does not do much. 

\subsection{The Parameter Factory}

Parameters can be loaded in a single step using the parameter factory methods,
much like the gtk menu item factory methods. The set of parameters to be
loaded should be described in an array of \verb!carmen_param_t!, and passed to
\begin{verbatim}
void carmen_param_install_params(int argc, char *argv[], carmen_param_p param_list, 
                                 int num_items);
\end{verbatim}

Each parameter in the array of type \verb!carmen_param_t! has the form:
\begin{verbatim}
typedef struct {
  char *module;
  char *variable;
  carmen_param_type_t type;
  void *user_variable;
  int subscribe;
  carmen_param_change_handler_t handler;
} carmen_param_t;
\end{verbatim}
where \verb!module! is the module name, \verb!variable! is the variable name,
\verb!type! is one of \verb!CARMEN_PARAM_INT!, \verb!CARMEN_PARAM_DOUBLE!,
\verb!CARMEN_PARAM_ONOFF! or \verb!CARMEN_PARAM_STRING!. The parameter is
loaded into \verb!user_variable!, whose original type should match that
specified in the \verb!type! field.

If \verb!subscribe! is set to 1, then the process will subscribe to changes to
the parameter, and set up a callback on the function specified in
\verb!handler! (if not NULL). The callback parameter is ignored if
\verb!subscribe! is set to 0, and the parameter is only loaded once. There is
no way to use the parameter factory methods, subscribe to a variable and not
have the variable's value updated automatically. 

If \verb!carmen_param_allow_unfound_variables()! is set to 0 (by default),
then \verb!carmen_param_install_params! will exit with an error on the first
parameter absent from the parameter server, reporting what the problematic
parameter is.

If a process loads its parameter set using the parameter factory methods, then
running the process with the \verb!-h! or \verb!-help! command line option
will print out a list of parameters used by that process, their expected types
and whether or not the process subscribes to changes.

\end{document}

\documentclass{article}

\title{CARMEN Style Guide}
\author{Nicholas Roy and Michael Montemerlo and Sebastian Thrun}
\date{Revised: May 23rd, 2002}

\begin{document}

\maketitle

\section{The Prime directive}

You are not the only person who will ever have to read, understand and modify
your code.

\section{Units and Coordinates}

\begin{itemize}
\item Always represent all units in MKS. All distances are {\em always} in
metres. All angles are {\em always, always} in radians.

\item All floating point numbers should be doubles, not floats, and all fixed
point numbers should be ints, not chars or shorts. The only known exceptions
are large, low-precision data chunks, i.e. laser data and maps.

\item All co-ordinate frames, internal and external, are right-handed. This
means that $\theta$ {\em always} increases counter-clockwise, from positive x
to positive y. This is the {\em opposite} of screen graphics. 

\item $\theta = 0$ {\em always} points along the positive x axis.

\item There are exactly three allowable co-ordinate frames. 
\begin{enumerate}
\item The robot's frame of reference. Distances are in metres, and the robot
  always faces along the positive x axis.
\item The global frame of reference. Distances are in metres, and $\theta = 0$
  is with respect to a map. This is a meaningless frame of reference without a
  map.
\item The map frame of reference. Distances are in grid cells, and $\theta =
  0$ is with respect to a map. This is a meaningless frame of reference
  without a map.
\end{enumerate}

\item Never convert between radians and degrees yourself. Always use \\
\verb!carmen_radians_to_degrees! and \verb!carmen_degrees_to_radians!.

\item Angles are always between $-\pi$ and $\pi$. Never normalize angles
yourself. Always use \verb!carmen_normalize_theta!.

\item Never use \verb!asin!, \verb!acos! or \verb!atan! to recover angles
distances. Always use \verb!atan2 (3)!.
\begin{verbatim}
           theta = atan2(y, x);
\end{verbatim}
should always be used instead of 
\begin{verbatim}
           theta = atan(y/x);
\end{verbatim}

\item If you need the hypotenuse of something, use \verb!hypot (3)! -- do
not take the sum of squares and find the square root. \verb! hypot (3)! 
should be used for code clarity.

\item Try not to invent your own data structures. Use one of
  \begin{itemize}
  \item \verb!carmen_point_t!
  \item \verb!carmen_traj_point_t!
  \item \verb!carmen_map_point_t!
  \item \verb!carmen_world_point_t!
  \end{itemize}
  making sure that you use the right data structure to store the right kind of
  data.
  
\item When converting between coordinate frames, use the helper functions in
  \verb!map_interface.h! and \verb!global.h!.
  
\item When drawing to the screen, do not maintain internal representations of
  data in screen co-ordinates. Convert to screen co-ordinates only immediately
  before calling extern graphics functions. Use the helper functions in
  \verb!global_graphics.h!.

\end{itemize}

\section{Naming conventions}

\begin{itemize}
  
\item The most important naming convention is to expect that your code could
  be converted into a library one day. Therefore, it is important to think
  about global name spaces.

\item As many functions and global variables should be static as possible. In
general, try to avoid global variables. 

\item Static global variables with accessor functions are preferable to
non-static globals.

\item Any non-static functions and global variables must have the prepend
\verb!carmen_{module-name}!. e.g., \verb!carmen_base_subscribe_odometry!.

\end{itemize}

\section{Memory management, system calls, and functions with side effects}

\begin{itemize}

\item Never use a system call without checking the return value. This includes
any memory allocation. We have provided a function \\ \verb!carmen_test_alloc!
that facilitates memory checking. CVS will not allow code to be committed to
core CARMEN that contains a call to malloc/calloc/realloc and does not have a
call to \verb!carmen_test_alloc! on the subsequent line.

\item When using statically allocated arrays, especially strings, never make
the array ``just big enough''. 

\begin{itemize}
\item Wrong: \verb!char buffer[11]! for a string of length 10.  
\item Right: \verb!char buffer[1024]! for a string of length 10.
\end{itemize}

Why? You minimize the probability of off-by-one errors writing into memory you
don't own. Memory is cheap. If you really need to create ``just-big-enough''
memory arrays because you're running out of memory, you're solving the wrong
problem. 

\item Never use fscanf, gets, etc to read into buffers without limit. 

\item Never make a system call, and check its side effect in one step. For
example, 
\begin{verbatim}
           fd = open(filename, O_RDONLY);
           if (fd < 0)
             return -1;
\end{verbatim}
should always be used instead of 
\begin{verbatim}
           if ((fd = open(filename, O_RDONLY)) < 0)
             return -1;
\end{verbatim}
This is for two reasons:
  \begin{itemize}
  \item Code clarity : it is easier to read the former than the latter.
  \item Debugging : it is easier to use a debugger with the former than the latter. 
  \end{itemize}
  
\item Avoid macros. If you must have a macro, write an inline function
instead. Macros can hurt you in the following manner:
\begin{verbatim}
           #define MAX(X, Y) ((X) > (Y) ? (X) : (Y))
           ...
                  max_x = MAX(X++, Y++);
\end{verbatim}
The larger of the two fields will be incremented {\em twice}.
Instead, use:
\begin{verbatim}
           inline int max_int(int x, int y) {
             return (x > y ? x : y);
           }
\end{verbatim}
Under compiler flags \verb!-O!, these two code fragments are compiled
identically under gcc, but the macro has unexpected side-effects.

\item Never generate random numbers yourself. You will do it wrong. Always use
one of \verb!carmen_int_random!, \verb!carmen_uniform_random! or
\verb!carmen_gaussian_random!. Consult the documentation for these functions to
find out which random algorithm they use. 

\item Never create random number seeds yourself. You will do it wrong. Always
use \verb!carmen_randomize!. This function randomizes by reading a seed from
\verb!/dev/random!.

\end{itemize}

\section{IPC}

\begin{itemize}

\item Do not initialize IPC yourself. Use \verb!carmen_initialize_ipc!. 

\item If you write a stand-alone module, there should be three separate files
  with your module:
  \begin{itemize}
  \item \verb!{module}_messages.h! -- this contains the IPC message
    definitions.
  \item \verb!{module}_interface.h! -- this contains the function prototypes
  for communicating with your module.
  \item \verb!{module}_interface.c! -- this contains the actual functions
  for communicating with your module. This file should be compiled into a
  library. 
  \end{itemize}

  We expect that all modules will have well-defined interface libraries that
  relieve the user of having to worry about marshalling data.

\item Every IPC message should have a timestamp and hostname field. The
hostname should be 10 chars long, and should be a canonical representation of
the machine on which the process is running that created the message. Use the
helper function \verb!carmen_get_tenchar_host_name()! to generate the
hostname. 

The timestamp should also reflect the time of creation of the \emph{data}, not
the time the message was published. For instance, the laser message timestamp
is the time the data was read from the serial port. Use the helper function
\verb!carmen_get_time_ms()! to generate the timestamp as a double.

\end{itemize}

\section{Graphics}

\begin{itemize}

\item Keep graphics and robot functionality in separate processes. 
  
  Notice that none of the core robot functionality (\verb!base_services!,
  \verb!robot!, \verb!navigator!, \verb!localize!) link against graphics
  libraries. This is for multiple reasons:
  
  \begin{enumerate}
  \item It increases the likelihood that your code will work on a standalone
    robot in the absence of a network. If your process is displaying output to
    a remote X window, and the network drops out, your process \emph{will}
    wedge until the network comes back. If, however, your process is sending
    IPC messages to an external display process, then only the display process
    will wedge, not your (presumably more important) robot process.
    
  \item You are removed from the temptation of displaying internal information
    not accessible to external code. If you want to \emph{see} the state of
    your process, the odds are very high that eventually, someone else will
    want to \emph{use} the state of your process. By forcing you to write an
    IPC message and interface handler for that information just to get it into
    the display, you make life much easier for people who come after you.
    
  \item Allowing your code to compile without graphics makes it more portable,
    and makes it more distributable, in the sense that it can run anywhere --
    it is not constrained by the speed of network connections between
    machines.
  \end{enumerate}
  
  For obvious reasons, programs like map\_editor and mapper have displays
  compiled in -- these programs are not intended for autonomous use on the
  robot.
\end{itemize}


\end{document}
